////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
//ANTIKERNEL v0.1                                                                                                     //
//                                                                                                                    //
//Copyright (c) 2012-2016 Andrew D. Zonenberg                                                                         //
//All rights reserved.                                                                                                //
//                                                                                                                    //
//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the    //
//following conditions are met:                                                                                       //
//                                                                                                                    //
//   * Redistributions of source code must retain the above copyright notice, this list of conditions, and the        //
//     following disclaimer.                                                                                          //
//                                                                                                                    //
//   * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the      //
//     following disclaimer in the documentation and/or other materials provided with the distribution.               //
//                                                                                                                    //
//   * Neither the name of the author nor the names of any contributors may be used to endorse or promote products    //
//     derived from this software without specific prior written permission.                                          //
//                                                                                                                    //
//THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  //
//TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL//
//THE AUTHORS BE HELD LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES       //
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR      //
//BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT//
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE      //
//POSSIBILITY OF SUCH DAMAGE.                                                                                         //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// @file
// @author Andrew D. Zonenberg
// @brief Opcode constants used by jtagd

//Each request begins with the client sending a uint8_t containing an opcode to the server.
//All ASCII strings are sent as a uint16_t followed by a raw (non-null-terminated) string

JTAGD_OP_GET_NAME 	 		8'h00	//Query the name of the JTAG adapter
									//Server responds with a string
JTAGD_OP_GET_SERIAL  		8'h01	//Query the serial number of the JTAG adapter
									//Server responds with a string
JTAGD_OP_GET_USERID 		8'h02	//Query the user-chosen ID of the JTAG adapter
									//Server responds with a string
JTAGD_OP_GET_FREQ 			8'h03	//Query the frequency of the JTAG interface
									//Server responds with a uint32_t
//8'h04 - 8'h05 reserved for deprecated opcodes
JTAGD_OP_SHIFT_DATA_WO 		8'h06	//Shift data with no response
									//uint8_t last_tms
									//uint32_t count [BITS]
									//[data]
									//Server responds with data
JTAGD_OP_SHIFT_DATA 		8'h07	//Shift data with response
									//uint8_t last_tms
									//uint32_t count [BITS]
									//[data]
									//Server responds with data
JTAGD_OP_DUMMY_CLOCK 		8'h08	//Send dummy clocks
									//uint32_t count
JTAGD_OP_PERF_SHIFT 		8'h09	//Gets number of shift operations
									//Server responds with uint64_t
JTAGD_OP_PERF_RECOV 		8'h0a	//Gets number of recoverable errors
									//Server responds with uint64_t
JTAGD_OP_PERF_DATA 			8'h0b	//Gets number of data bits shifted
									//Server responds with uint64_t
JTAGD_OP_PERF_MODE 			8'h0c	//Gets number of mode bits shifted
									//Server responds with uint64_t
JTAGD_OP_PERF_DUMMY 		8'h0d	//Gets number of dummy clocks sent
									//Server responds with uint64_t

JTAGD_OP_QUIT				8'h0e	//Requests that the server close the connection
JTAGD_OP_COMMIT 			8'h0f	//Commits outstanding writes
JTAGD_OP_SPLIT_SUPPORTED	8'h10	//Checks if split scan is supported
JTAGD_OP_SHIFT_DATA_WRITE_ONLY 	8'h11	//Shift data
									//uint8_t tms
									//uint8_t last_tms
									//uint32_t count [BITS]
									//uint8_t want_response
									//[data]
									//Server responds with a status byte indicating if the read was deferred
									//and if not the data
JTAGD_OP_SHIFT_DATA_READ_ONLY 	8'h12	//Shift data
									//uint32_t count [BITS]
									//Server responds with a status byte indicating if the read was deferred
									//and if so the data

JTAGD_OP_DUMMY_CLOCK_DEFERRED	8'h13	//Send dummy clocks without flushing the pipeline
									//uint32_t count

JTAGD_OP_HAS_GPIO 	 		8'h14	//Indicates if the JTAG adapter is GPIO capable
									//Returns a uint8_t
JTAGD_OP_GET_GPIO_PIN_COUNT	8'h15	//Gets the number of GPIO pins the adapter has
									//Returns a uint8_t
JTAGD_OP_READ_GPIO_STATE 	8'h16	//Read GPIO pin state
									//Returns a uint8_t for each pin bit0 	 value bit1 	 direction
JTAGD_OP_WRITE_GPIO_STATE 	8'h17	//Write GPIO pin state
									//Followed by a uint8_t for each pin bit0 	 value bit1 	 direction

JTAGD_OP_TLR 				8'h18	//Enter test-logic-reset
JTAGD_OP_ENTER_SIR 	 		8'h19	//Enter Shift-IR
JTAGD_OP_LEAVE_E1IR 	 	8'h1a	//Leave Exit1-IR
JTAGD_OP_ENTER_SDR 	 		8'h1b	//Enter Shift-DR
JTAGD_OP_LEAVE_E1DR 	 	8'h1c	//Leave Exit1-DR
JTAGD_OP_RESET_IDLE 	 	8'h1d	//Reset to idle

JTAGD_OP_COUNT				8'h1e	//number of opcodes
