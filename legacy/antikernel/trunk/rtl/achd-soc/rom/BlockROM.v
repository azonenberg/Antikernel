`timescale 1ns / 1ps
/***********************************************************************************************************************
*                                                                                                                      *
* ANTIKERNEL v0.1                                                                                                      *
*                                                                                                                      *
* Copyright (c) 2012-2016 Andrew D. Zonenberg                                                                          *
* All rights reserved.                                                                                                 *
*                                                                                                                      *
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the     *
* following conditions are met:                                                                                        *
*                                                                                                                      *
*    * Redistributions of source code must retain the above copyright notice, this list of conditions, and the         *
*      following disclaimer.                                                                                           *
*                                                                                                                      *
*    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the       *
*      following disclaimer in the documentation and/or other materials provided with the distribution.                *
*                                                                                                                      *
*    * Neither the name of the author nor the names of any contributors may be used to endorse or promote products     *
*      derived from this software without specific prior written permission.                                           *
*                                                                                                                      *
* THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   *
* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL *
* THE AUTHORS BE HELD LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES        *
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR       *
* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT *
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE       *
* POSSIBILITY OF SUCH DAMAGE.                                                                                          *
*                                                                                                                      *
***********************************************************************************************************************/

/**
	@file
	@author Andrew D. Zonenberg
	@brief Block ROM, globally readable
	
	Eight 2KB pages by default.
 */
module BlockROM(
	
	//Clocks
	clk,
	
	//NoC interface
	rpc_tx_en, rpc_tx_data, rpc_tx_ack, rpc_rx_en, rpc_rx_data, rpc_rx_ack,
	dma_tx_en, dma_tx_data, dma_tx_ack, dma_rx_en, dma_rx_data, dma_rx_ack
	);
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// I/O declarations
	
	//Clocks
	input wire clk;
	
	//NoC interface
	output wire rpc_tx_en;
	output wire[31:0] rpc_tx_data;
	input wire[1:0] rpc_tx_ack;
	input wire rpc_rx_en;
	input wire[31:0] rpc_rx_data;
	output wire[1:0] rpc_rx_ack;
	
	output wire dma_tx_en;
	output wire[31:0] dma_tx_data;
	input wire dma_tx_ack;
	input wire dma_rx_en;
	input wire[31:0] dma_rx_data;
	output wire dma_rx_ack;
	
	parameter init_file = "";
	parameter wordsize = 4096;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// NoC transceivers
	
	`include "DMARouter_constants.v"
	`include "RPCv2Router_type_constants.v"	//Pull in autogenerated constant table
	`include "RPCv2Router_ack_constants.v"
	
	parameter NOC_ADDR = 16'h0000;
	
	reg			rpc_fab_tx_en 		= 0;
	reg[15:0]	rpc_fab_tx_dst_addr	= 0;
	reg[7:0]	rpc_fab_tx_callnum	= 0;
	reg[2:0]	rpc_fab_tx_type		= 0;
	reg[20:0]	rpc_fab_tx_d0		= 0;
	reg[31:0]	rpc_fab_tx_d1		= 0;
	reg[31:0]	rpc_fab_tx_d2		= 0;
	wire		rpc_fab_tx_done;
	
	wire		rpc_fab_rx_en;
	wire[15:0]	rpc_fab_rx_src_addr;
	wire[15:0]	rpc_fab_rx_dst_addr;
	wire[7:0]	rpc_fab_rx_callnum;
	wire[2:0]	rpc_fab_rx_type;
	wire[20:0]	rpc_fab_rx_d0;
	wire[31:0]	rpc_fab_rx_d1;
	wire[31:0]	rpc_fab_rx_d2;
	reg			rpc_fab_rx_done		= 0;
	wire		rpc_fab_inbox_full;
	
	RPCv2Transceiver #(
		.LEAF_PORT(1),
		.LEAF_ADDR(NOC_ADDR)
	) txvr(
		.clk(clk),
		
		.rpc_tx_en(rpc_tx_en),
		.rpc_tx_data(rpc_tx_data),
		.rpc_tx_ack(rpc_tx_ack),
		
		.rpc_rx_en(rpc_rx_en),
		.rpc_rx_data(rpc_rx_data),
		.rpc_rx_ack(rpc_rx_ack),
		
		.rpc_fab_tx_en(rpc_fab_tx_en),
		.rpc_fab_tx_src_addr(16'h0000),
		.rpc_fab_tx_dst_addr(rpc_fab_tx_dst_addr),
		.rpc_fab_tx_callnum(rpc_fab_tx_callnum),
		.rpc_fab_tx_type(rpc_fab_tx_type),
		.rpc_fab_tx_d0(rpc_fab_tx_d0),
		.rpc_fab_tx_d1(rpc_fab_tx_d1),
		.rpc_fab_tx_d2(rpc_fab_tx_d2),
		.rpc_fab_tx_done(rpc_fab_tx_done),
		
		.rpc_fab_rx_en(rpc_fab_rx_en),
		.rpc_fab_rx_src_addr(rpc_fab_rx_src_addr),
		.rpc_fab_rx_dst_addr(rpc_fab_rx_dst_addr),
		.rpc_fab_rx_callnum(rpc_fab_rx_callnum),
		.rpc_fab_rx_type(rpc_fab_rx_type),
		.rpc_fab_rx_d0(rpc_fab_rx_d0),
		.rpc_fab_rx_d1(rpc_fab_rx_d1),
		.rpc_fab_rx_d2(rpc_fab_rx_d2),
		.rpc_fab_rx_done(rpc_fab_rx_done),
		.rpc_fab_inbox_full(rpc_fab_inbox_full)
		);
	
	//DMA transmit signals
	wire dtx_busy;
	reg[15:0] dtx_dst_addr = 0;
	reg[1:0] dtx_op = 0;
	reg[9:0] dtx_len = 0;
	reg[31:0] dtx_addr = 0;
	reg dtx_en = 0;
	wire dtx_rd;
	wire[9:0] dtx_raddr;
	wire[31:0] dtx_buf_out;
	
	//DMA receive signals
	reg drx_ready = 1;
	wire drx_en;
	wire[15:0] drx_src_addr;
	wire[15:0] drx_dst_addr;
	wire[1:0] drx_op;
	wire[31:0] drx_addr;
	wire[9:0] drx_len;	
	
	//DMA transceiver
	DMATransceiver #(
		.LEAF_PORT(1),
		.LEAF_ADDR(NOC_ADDR)
	) dma_txvr(
		.clk(clk),
		.dma_tx_en(dma_tx_en), .dma_tx_data(dma_tx_data), .dma_tx_ack(dma_tx_ack),
		.dma_rx_en(dma_rx_en), .dma_rx_data(dma_rx_data), .dma_rx_ack(dma_rx_ack),
		
		.tx_done(),
		.tx_busy(dtx_busy), .tx_src_addr(16'h0000), .tx_dst_addr(dtx_dst_addr), .tx_op(dtx_op), .tx_len(dtx_len),
		.tx_addr(dtx_addr), .tx_en(dtx_en), .tx_rd(dtx_rd), .tx_raddr(dtx_raddr), .tx_buf_out(dtx_buf_out),
		
		.rx_ready(drx_ready), .rx_en(drx_en), .rx_src_addr(drx_src_addr), .rx_dst_addr(drx_dst_addr),
		.rx_op(drx_op), .rx_addr(drx_addr), .rx_len(drx_len),
		.rx_buf_rd(1'h0), .rx_buf_addr(9'h0), .rx_buf_data(), .rx_buf_rdclk(clk)
		);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// The actual memory bank
	
	//number of bits in the address bus
	`include "../util/clog2.vh"
	localparam ADDR_BITS = clog2(wordsize);
	
	//The page ID of the current address
	//Bottom 11 bits are the address within the page
	//31:27 and 3:0 must always be zero
	wire[15:0] drx_page_id = drx_addr[26:11];
	wire[31:0] drx_end_addr = drx_addr + drx_len;
	wire[15:0] drx_end_page_id = drx_end_addr[26:11];
	
	//Readout logic
	wire[8:0] dtx_block_addr	= dtx_raddr + drx_addr[10:2];
	wire[31:0] dtx_mem_addr		= {drx_page_id, dtx_block_addr};
	
	MemoryMacro #(
		.WIDTH(32),
		.DEPTH(wordsize),
		.DUAL_PORT(0),
		.TRUE_DUAL(0),
		.USE_BLOCK(1),
		.OUT_REG(1),
		.INIT_ADDR(0),
		.INIT_FILE(init_file)
	) storage (
		.porta_clk(clk),
		.porta_en(dtx_rd),
		.porta_addr(dtx_mem_addr[ADDR_BITS-1 : 0]),
		.porta_we(1'b0),
		.porta_din(32'h0),
		.porta_dout(dtx_buf_out),
		
		.portb_clk(clk),
		.portb_en(1'b0),
		.portb_addr({ADDR_BITS{1'b0}}),
		.portb_we(1'b0),
		.portb_din(32'h0),
		.portb_dout()
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Main state machine
	
	`include "NetworkedDDR2Controller_opcodes_constants.v"
	
	reg dma_message_pending = 0;
	
	localparam STATE_IDLE			= 4'h0;
	localparam STATE_DMA_TXHOLD		= 4'h1;
	localparam STATE_RPC_TXHOLD		= 4'h2;
	
	reg[3:0] state = STATE_IDLE;
	
	always @(posedge clk) begin
	
		rpc_fab_tx_en <= 0;
		rpc_fab_rx_done <= 0;
		dtx_en <= 0;
		
		//When a message comes in and we're busy, make a note of it
		if(drx_en) begin
			dma_message_pending <= 1;
			drx_ready <= 0;
		end
		
		case(state)
			
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// Nothing to do

			STATE_IDLE: begin
				
				//See if any RPC commands are here
				if(rpc_fab_inbox_full) begin
					
					//Prepare to respond to whatever we got
					rpc_fab_tx_dst_addr <= rpc_fab_rx_src_addr;
					rpc_fab_tx_callnum <= rpc_fab_rx_callnum;
					
					//Everything is single cycle
					rpc_fab_rx_done <= 1;
					
					//Remote procedure call - return failure (we don't implement any calls)
					if(rpc_fab_rx_type == RPC_TYPE_CALL) begin
						rpc_fab_tx_type <= RPC_TYPE_RETURN_FAIL;
						rpc_fab_tx_d0 <= 0;
						rpc_fab_tx_d1 <= 0;
						rpc_fab_tx_d2 <= 0;
						rpc_fab_tx_en <= 1;
						state <= STATE_RPC_TXHOLD;
					end
					
				end	//end check for rpc messages
				
				//See if any DMA commands are here
				else if(drx_en || dma_message_pending) begin
					dma_message_pending <= 0;
					
					case(drx_op)
						
						//We're a ROM, deny all writes
						DMA_OP_WRITE_REQUEST: begin
							rpc_fab_tx_dst_addr <= drx_src_addr;
							rpc_fab_tx_callnum <= RAM_OP_FAILED;
							rpc_fab_tx_type <= RPC_TYPE_INTERRUPT;
							rpc_fab_tx_d0 <= drx_len;
							rpc_fab_tx_d1 <= drx_addr;
							rpc_fab_tx_d2 <= 0;
							rpc_fab_tx_en <= 1;
							state <= STATE_RPC_TXHOLD;
						end	//end DMA_OP_WRITE_REQUEST
						
						//Process reads
						DMA_OP_READ_REQUEST: begin
							dtx_en <= 1;
							dtx_addr <= drx_addr;
							dtx_len <= drx_len;
							dtx_dst_addr <= drx_src_addr;
							dtx_op <= DMA_OP_READ_DATA;
							state <= STATE_DMA_TXHOLD;
						end	//end DMA_OP_READ_REQUEST
						
						//ignore other stuff
						default: begin

							rpc_fab_tx_dst_addr <= drx_src_addr;
							rpc_fab_tx_callnum <= RAM_OP_FAILED;
							rpc_fab_tx_type <= RPC_TYPE_INTERRUPT;
							rpc_fab_tx_d0 <= drx_len;
							rpc_fab_tx_d1 <= drx_addr;
							rpc_fab_tx_d2 <= 0;
							rpc_fab_tx_en <= 1;
							
							state <= STATE_RPC_TXHOLD;
							
						end
						
					endcase

				end	//end check for dma messages

			end	//end STATE_IDLE
			
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// DMA helper states
			
			STATE_DMA_TXHOLD: begin
				if(!dtx_en && !dtx_busy) begin
					drx_ready <= 1;
					state <= STATE_IDLE;
				end
			end //end STATE_DMA_TXHOLD
			
			STATE_RPC_TXHOLD: begin
				if(rpc_fab_tx_done) begin
					drx_ready <= 1;
					state <= STATE_IDLE;
				end
			end	//end STATE_RPC_TXHOLD
			
		endcase

	end
	
endmodule
