/***********************************************************************************************************************
*                                                                                                                      *
* ANTIKERNEL v0.1                                                                                                      *
*                                                                                                                      *
* Copyright (c) 2012-2016 Andrew D. Zonenberg                                                                          *
* All rights reserved.                                                                                                 *
*                                                                                                                      *
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the     *
* following conditions are met:                                                                                        *
*                                                                                                                      *
*    * Redistributions of source code must retain the above copyright notice, this list of conditions, and the         *
*      following disclaimer.                                                                                           *
*                                                                                                                      *
*    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the       *
*      following disclaimer in the documentation and/or other materials provided with the distribution.                *
*                                                                                                                      *
*    * Neither the name of the author nor the names of any contributors may be used to endorse or promote products     *
*      derived from this software without specific prior written permission.                                           *
*                                                                                                                      *
* THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   *
* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL *
* THE AUTHORS BE HELD LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES        *
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR       *
* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT *
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE       *
* POSSIBILITY OF SUCH DAMAGE.                                                                                          *
*                                                                                                                      *
***********************************************************************************************************************/

/**
	@file
	@author Andrew D. Zonenberg
	@brief Implementation of WaveformView
 */

#include "tdrview.h"
#include "WaveformView.h"
#include "MainWindow.h"
#include "../scopehal/scopehal.h"

#define HEIGHT 768

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Construction / destruction
WaveformView::WaveformView(MainWindow* parent)
	: m_parent(parent)
{
	add_events(
		Gdk::EXPOSURE_MASK |
		Gdk::BUTTON_PRESS_MASK |
		Gdk::BUTTON_RELEASE_MASK |
		Gdk::POINTER_MOTION_MASK);
		
	//Allocate our pixel array
	m_pixels = new RGBTRIPLE[NUM_SAMPLES * HEIGHT];
	
	set_size(NUM_SAMPLES,HEIGHT);
	
	m_cursors[0] = 0;
	m_cursors[1] = 0;
	m_mousedown = false;
}

WaveformView::~WaveformView()
{
	delete[] m_pixels;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Rendering

bool WaveformView::on_draw(const Cairo::RefPtr<Cairo::Context>& cr)
{
	Glib::RefPtr<Gdk::Window> window = get_bin_window();
	if(window)
	{	
		//printf("========== NEW FRAME ==========\n");
		
		//Get dimensions of the virtual canvas (max of requested size and window size)
		/*
		Gtk::Allocation allocation = get_allocation();
		int width = allocation.get_width();
		int height = allocation.get_height();
		if(m_width > width)
			width = m_width;
		if(m_height > height)
			m_height = height;
		*/
		
		//Get the visible area of the window
		unsigned int pwidth = get_width();
		unsigned int pheight = get_height();
	
		//Set up drawing context
		cr->save();
		cr->set_identity_matrix();
		
		//Fill background
		cr->set_source_rgb(0, 0, 0);
		cr->rectangle(0, 0, NUM_SAMPLES, pheight);
		cr->fill();
		
		//Create the bitmap
		m_parent->m_bufmutex.lock();
			#pragma omp parallel for
			//for(int y=0; y<DAC_BINS; y++)
			for(unsigned  y=1664; y<2432; y++)
			{
				//TMP: 4x zoom
				//TODO: Invert the weird vertical flip
				for(unsigned  x=0; x<NUM_SAMPLES; x++)
					m_pixels[(y-1664)*NUM_SAMPLES + x] = TransferFunction(
						m_parent->m_normsamples[x][y]);
			}
		m_parent->m_bufmutex.unlock();
		
		//Create the pixbuf
		Glib::RefPtr< Gdk::Pixbuf > pixbuf = Gdk::Pixbuf::create_from_data(
			reinterpret_cast<unsigned char*>(&m_pixels[0]), 
			Gdk::COLORSPACE_RGB,
			false,
			8,
			NUM_SAMPLES,
			HEIGHT,
			NUM_SAMPLES * 3);
			
		//Make a surface and grab a context from it
		Cairo::RefPtr< Cairo::ImageSurface > surface =
			Cairo::ImageSurface::create(Cairo::FORMAT_RGB24, NUM_SAMPLES, HEIGHT);
		Cairo::RefPtr< Cairo::Context > context = Cairo::Context::create(surface);
		Gdk::Cairo::set_source_pixbuf(context, pixbuf, 0.0, 0.0);
		context->paint();
		
		const unsigned int timescale_height = 24;
		
		//Draw the final image
		cr->save();
			cr->set_source(surface, 0.0, 0.0);
			cr->translate(0, timescale_height);
			cr->rectangle(0, 0, NUM_SAMPLES, HEIGHT);
			cr->clip();
			cr->paint();
		cr->restore();
		
		//Draw the time scale
		Gdk::Color color("white");
		cr->set_source_rgb(color.get_red_p(), color.get_green_p(), color.get_blue_p());
		
		//Draw top line
		cr->move_to(0, 0);
		cr->line_to(pwidth, 0);
		cr->stroke();
		
		//TODO: allow adjusting this
		//Note, this is RTT delay, not one way.
		const float ns_per_meter = 10;
		
		//Draw a line every 100 samples
		//For now, hard code 1 sample per pixel
		const unsigned int minor_line = 10;
		const unsigned int major_line = 20;
		const unsigned int minor_grad = 20;
		const unsigned int major_grad = minor_grad*5;
		for(unsigned int x=0; x<NUM_SAMPLES; x+= minor_grad)
		{
			bool major = ((x % major_grad) == 0);
			int y = major ? major_line : minor_line;
			
			cr->move_to(x, 0);
			cr->line_to(x, y);
			cr->stroke();
			
			//Draw the text
			if(major)
			{
				float t = (x*m_parent->m_samplePeriod) / 1000.0f;
				char namebuf[128];
				snprintf(namebuf, sizeof(namebuf), "%.1f ns", t);
				DrawString(x + 5, 10, cr, namebuf, false);
			}
		}
		
		//Draw the cursors
		for(int i=0; i<2; i++)
		{
			if(i == 0)
				cr->set_source_rgb(1, 1, 0);
			else
				cr->set_source_rgb(0, 1, 1);
			
			//Cursor itself
			float x = m_cursors[i] / m_parent->m_samplePeriod;
			cr->move_to(x, 0);
			cr->line_to(x, HEIGHT);
			cr->stroke();
			
			float delta = (m_cursors[1] - m_cursors[0]) / 1000.0f;
			
			//Format text
			char tbuf[128];
			float t = m_cursors[i] / 1000.0f;
			if(i == 0)
				snprintf(tbuf, sizeof(tbuf), "%.1f ns / %.2f m", t, t/ns_per_meter);
			else
			{
				snprintf(tbuf, sizeof(tbuf), "%.1f ns / %.2f m\n\u0394 = %.1f ns / %.2f m",
					t, t/ns_per_meter,
					delta, delta/ns_per_meter);
			}
			int swidth = 0, sheight = 0;
			GetStringWidth(cr, tbuf, true, swidth, sheight);
			
			//Outline box for the text
			int ybase = 25;
			int margin = 3;
			cr->move_to(x,						ybase);
			cr->line_to(x, 						ybase + sheight + 2*margin);
			cr->line_to(x + swidth + 2*margin,	ybase + sheight + 2*margin);
			cr->line_to(x + swidth + 2*margin,	ybase);
			cr->line_to(x,						ybase);
			cr->fill();
			
			//Text itself
			cr->set_source_rgb(0, 0, 0);
			DrawString(x+margin, ybase+margin, cr, tbuf, false);
		}
		
		//TODO: Draw the grid
		
		//Done			
		cr->restore();
	}
	
	return true;
}

bool WaveformView::on_button_press_event(GdkEventButton* event)
{
	//only want left button
	if(event->button != 1)
		return true;
	
	m_mousedown = true;
		
	m_cursors[0] = m_parent->m_samplePeriod * event->x;
	
	return true;
}

bool WaveformView::on_button_release_event(GdkEventButton* event)
{
	//only want left button
	if(event->button != 1)
		return true;
	
	m_mousedown = false;
	
	m_cursors[1] = m_parent->m_samplePeriod * event->x;
	
	return true;
}

bool WaveformView::on_motion_notify_event(GdkEventMotion* event)
{
	//ignore motion if not dragging
	if(!m_mousedown)
		return true;
		
	m_cursors[1] = m_parent->m_samplePeriod * event->x;
	queue_draw();
		
	return true;
}

//normalized float 0-1
RGBTRIPLE WaveformView::TransferFunction(float f)
{
	//Convert to 0-255
	int i = f * 255;
	if(i < 0)
		i = 0;
	if(i > 255)
		i = 255;
		
	//derived from GIMP "skyline" palette
	static const RGBTRIPLE table[256]=
	{
		{0x04,0x02,0x13},{0x08,0x05,0x2b},{0x0b,0x06,0x38},{0x0d,0x08,0x43},
		{0x0e,0x09,0x4b},{0x11,0x09,0x53},{0x11,0x0b,0x59},{0x12,0x0b,0x60},
		{0x14,0x0c,0x65},{0x14,0x0c,0x6a},{0x16,0x0d,0x6f},{0x16,0x0e,0x72},
		{0x17,0x0d,0x77},{0x17,0x0f,0x79},{0x18,0x0e,0x7c},{0x18,0x0f,0x7e},
		{0x18,0x0e,0x7e},{0x18,0x0f,0x7f},{0x18,0x0f,0x7f},{0x19,0x0f,0x80},
		{0x19,0x0f,0x80},{0x19,0x0f,0x81},{0x19,0x0f,0x81},{0x19,0x0f,0x82},
		{0x19,0x0f,0x82},{0x19,0x0f,0x82},{0x19,0x10,0x83},{0x19,0x0f,0x83},
		{0x19,0x10,0x84},{0x19,0x0f,0x84},{0x1a,0x0f,0x84},{0x1a,0x10,0x85},
		{0x19,0x10,0x85},{0x1a,0x0f,0x86},{0x1a,0x0f,0x85},{0x19,0x0f,0x86},
		{0x1a,0x10,0x86},{0x1a,0x0f,0x87},{0x1a,0x10,0x87},{0x1a,0x10,0x87},
		{0x1a,0x10,0x88},{0x1b,0x10,0x88},{0x1b,0x10,0x88},{0x1b,0x10,0x88},
		{0x1a,0x10,0x88},{0x1b,0x10,0x89},{0x1b,0x10,0x89},{0x1a,0x10,0x89},
		{0x1b,0x10,0x8a},{0x1b,0x10,0x8a},{0x1b,0x11,0x8a},{0x1a,0x10,0x8b},
		{0x1b,0x11,0x8b},{0x1b,0x11,0x8b},{0x1b,0x10,0x8b},{0x1b,0x10,0x8c},
		{0x1b,0x10,0x8c},{0x1b,0x11,0x8c},{0x1c,0x10,0x8c},{0x1b,0x11,0x8d},
		{0x1b,0x10,0x8d},{0x1b,0x10,0x8d},{0x1b,0x10,0x8d},{0x1b,0x11,0x8e},
		{0x1b,0x10,0x8e},{0x1b,0x10,0x8d},{0x1b,0x11,0x8e},{0x1b,0x11,0x8e},
		{0x1b,0x11,0x8e},{0x1c,0x10,0x8e},{0x1b,0x10,0x8e},{0x1c,0x11,0x8e},
		{0x1b,0x11,0x8f},{0x1b,0x11,0x8f},{0x1c,0x10,0x8f},{0x1c,0x11,0x8f},
		{0x1c,0x11,0x90},{0x1c,0x11,0x8f},{0x1c,0x11,0x90},{0x1c,0x11,0x90},
		{0x1c,0x11,0x90},{0x1c,0x11,0x90},{0x1c,0x11,0x90},{0x1c,0x11,0x90},
		{0x1c,0x11,0x91},{0x1c,0x11,0x91},{0x1c,0x11,0x90},{0x1b,0x11,0x90},
		{0x1c,0x11,0x91},{0x1c,0x11,0x90},{0x1c,0x11,0x91},{0x1c,0x11,0x91},
		{0x1c,0x11,0x91},{0x1b,0x11,0x91},{0x1c,0x11,0x91},{0x1c,0x11,0x91},
		{0x1c,0x11,0x91},{0x1c,0x11,0x91},{0x1c,0x11,0x91},{0x1c,0x11,0x91},
		{0x1c,0x11,0x91},{0x1c,0x11,0x91},{0x1c,0x11,0x91},{0x1d,0x11,0x90},
		{0x1f,0x11,0x8f},{0x20,0x11,0x8e},{0x22,0x11,0x8d},{0x23,0x11,0x8c},
		{0x24,0x10,0x8b},{0x27,0x11,0x8a},{0x28,0x11,0x89},{0x29,0x10,0x88},
		{0x2b,0x11,0x87},{0x2c,0x10,0x86},{0x2e,0x10,0x85},{0x2f,0x10,0x84},
		{0x31,0x10,0x84},{0x33,0x10,0x82},{0x34,0x10,0x81},{0x36,0x11,0x80},
		{0x37,0x10,0x80},{0x39,0x10,0x7e},{0x3b,0x10,0x7e},{0x3c,0x10,0x7c},
		{0x3d,0x10,0x7b},{0x3f,0x10,0x7b},{0x41,0x10,0x79},{0x43,0x10,0x78},
		{0x44,0x10,0x77},{0x46,0x10,0x76},{0x46,0x10,0x75},{0x48,0x10,0x74},
		{0x4a,0x0f,0x73},{0x4c,0x10,0x72},{0x4d,0x10,0x71},{0x4f,0x0f,0x70},
		{0x50,0x10,0x6f},{0x51,0x10,0x6e},{0x53,0x0f,0x6d},{0x55,0x0f,0x6c},
		{0x56,0x10,0x6b},{0x58,0x0f,0x6a},{0x59,0x0f,0x69},{0x5b,0x0f,0x68},
		{0x5d,0x0f,0x67},{0x5e,0x0f,0x66},{0x5f,0x0f,0x65},{0x61,0x0f,0x64},
		{0x63,0x0f,0x63},{0x64,0x0e,0x62},{0x66,0x0f,0x61},{0x67,0x0e,0x60},
		{0x69,0x0f,0x5f},{0x6a,0x0f,0x5e},{0x6d,0x0f,0x5d},{0x6e,0x0e,0x5c},
		{0x6f,0x0f,0x5b},{0x71,0x0e,0x5a},{0x72,0x0e,0x59},{0x74,0x0e,0x58},
		{0x76,0x0e,0x57},{0x77,0x0e,0x56},{0x78,0x0e,0x55},{0x7a,0x0e,0x54},
		{0x7c,0x0e,0x53},{0x7d,0x0e,0x52},{0x7f,0x0e,0x51},{0x81,0x0e,0x50},
		{0x81,0x0e,0x4f},{0x83,0x0e,0x4d},{0x86,0x0d,0x4c},{0x88,0x0e,0x4b},
		{0x8b,0x0d,0x49},{0x8e,0x0d,0x47},{0x90,0x0d,0x45},{0x93,0x0d,0x44},
		{0x95,0x0e,0x42},{0x97,0x0d,0x40},{0x9a,0x0e,0x3f},{0x9d,0x0e,0x3d},
		{0x9f,0x0d,0x3c},{0xa2,0x0e,0x3a},{0xa4,0x0d,0x38},{0xa6,0x0d,0x37},
		{0xa9,0x0d,0x36},{0xac,0x0d,0x33},{0xae,0x0d,0x32},{0xb1,0x0d,0x31},
		{0xb3,0x0c,0x2f},{0xb5,0x0c,0x2d},{0xb8,0x0c,0x2c},{0xba,0x0c,0x2a},
		{0xbd,0x0d,0x28},{0xbf,0x0c,0x27},{0xc2,0x0c,0x25},{0xc5,0x0c,0x24},
		{0xc7,0x0c,0x22},{0xca,0x0c,0x20},{0xcc,0x0c,0x1f},{0xce,0x0c,0x1d},
		{0xd1,0x0b,0x1b},{0xd4,0x0c,0x1a},{0xd6,0x0b,0x18},{0xd9,0x0b,0x16},
		{0xdb,0x0c,0x15},{0xdd,0x0b,0x13},{0xe0,0x0b,0x12},{0xe2,0x0b,0x10},
		{0xe5,0x0b,0x0f},{0xe7,0x0b,0x0c},{0xea,0x0b,0x0b},{0xeb,0x10,0x0b},
		{0xec,0x16,0x0a},{0xed,0x1c,0x09},{0xee,0x21,0x09},{0xef,0x27,0x09},
		{0xf0,0x2d,0x08},{0xf1,0x32,0x08},{0xf2,0x37,0x07},{0xf2,0x3d,0x07},
		{0xf4,0x43,0x06},{0xf4,0x48,0x06},{0xf5,0x4c,0x06},{0xf5,0x4f,0x05},
		{0xf6,0x52,0x04},{0xf6,0x55,0x05},{0xf6,0x57,0x04},{0xf8,0x5b,0x04},
		{0xf8,0x5d,0x04},{0xf8,0x61,0x03},{0xf9,0x64,0x03},{0xf9,0x66,0x03},
		{0xfa,0x69,0x03},{0xfb,0x6c,0x02},{0xfa,0x70,0x02},{0xfb,0x72,0x02},
		{0xfb,0x75,0x01},{0xfd,0x78,0x01},{0xfc,0x7b,0x01},{0xfd,0x7e,0x01},
		{0xfe,0x81,0x01},{0xfe,0x84,0x00},{0xff,0x87,0x00},{0xfe,0x8c,0x02},
		{0xfd,0x92,0x06},{0xfc,0x97,0x08},{0xfc,0x9c,0x0b},{0xfb,0xa2,0x0e},
		{0xfa,0xa8,0x12},{0xf9,0xad,0x15},{0xf8,0xb3,0x17},{0xf8,0xb9,0x1b},
		{0xf6,0xbe,0x1d},{0xf5,0xc2,0x20},{0xf5,0xc7,0x23},{0xf4,0xcb,0x26}
	};
	
	return table[i];
}
