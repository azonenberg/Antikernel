=================================================

TODO: Figure out what to do when nobody wants to read a message (the destination address is nonexistent)? Possible
DoS in current implementation if no JTAG. This is outside the scope of proofs done so far.

=================================================

GOAL: Prove that the RPC network is correct.

More formally, given:
* A network of RPCv2Router modules connected in a tree
  * Each child router's uplink signals are connected to one of parent node's downstream ports
  * PORT_DISABLE is set to 1 on all unused router ports
  * HOST_BIT_HIGH is set to the index of the leftmost bit in the host mask
  * SUBNET_ADDR is set to the prefix of the router's subnet
  * SUBNET_MASK is set to the appropriate bitmask for the subnet
* A leaf node connected to each enabled port of each RPCv2Router at the lowest level of the tree
  * Each leaf node contains an RPCv2Transceiver or RPCv2RouterTransceiver
  * The transceiver has LEAF_PORT set to 1 and LEAF_ADDR set to the appropriate address for that node

We want to prove:
* Packets are forwarded intact and unchanged to their intended recipient.
* No action taken by an leaf node can cause an invalid source address to appear in a packet. The origin of a packet
  cannot be misrepresented by the sender.
* No action taken by a leaf node can cause it to gain any knowledge about the contents of a packet it did not send or
  receive.
  
Note that this threat model does not preclude leaf nodes from doing very basic traffic analysis by measuring 
congestion on the network.

=================================================

DEFINITION 1

GIVEN: A unidirectional link consisting of one 32-bit bus "tx_data" and one 1-bit signal "tx_en" from sender to 
recipient, and one 2-bit bus "tx_ack" from recipient to sender. All signals are referenced to an externally supplied 
global clock.

We define a valid layer-2 RPC packet transmission sequence to be the following four states on successive clock cycles:
1) tx_en = 1, tx_data[31:16] = source address, tx_data[15:0] = destination address
2) tx_en = 0, tx_data = arbitrary layer-3 data
3) tx_en = 0, tx_data = arbitrary layer-3 data
4) tx_en = 0, tx_data = arbitrary layer-3 data

Once the packet is sent, it must be acknowledged. This is done by the "tx_ack" signal.

The tx_ack signal must have the value RPC_ACK_IDLE (0) at all times except when sending an acknowledgement.

At any time after the first cycle of the packet (either during or after transmission of the remaining three data 
words) the recipient may acknowledge receipt of the packet by placing a nonzero value on tx_ack for one cycle. The 
acknowledgement may be positive (RPC_ACK_ACK, 1) or negative (RPC_ACK_NAK, 2). The value 3 is undefined and must 
never be generated by a receiver.

Until an acknowledgement is received, the transmitter must not send any additional packets.

When a negative acknowledgement is received, the transmitter must re-send the previously sent packet. If the packet 
is still being transmitted, the transmitter must finish sending and then restart the transmit sequence from the 
beginning.

When a positive acknowledgement is received, the transmitter returns to the idle state and is able to begin sending 
another packet.

The tx_en signal must be zero at all times except the first cycle of a transmit sequence.

The tx_data signal must be zero at all times except during a transmit sequence.

=================================================

DEFINITION 2

We define a bidirectional RPC link to be two instances of the unidirectional structure described in Definition 1, 
facing in opposite directions such that packets may be sent from either node to the other.

=================================================

DEFINITION 3

The layer-3 RPC protocol defines the following interpretation of a layer-2 RPC packet's contents:

Cycle 1, bits 31:24 = RPC call number
Cycle 1, bits 23:21 = packet type
Cycle 1, bits 20:0  = arbitrary layer-4 data
Cycle 2, bits 31:0  = arbitrary layer-4 data
Cycle 3, bits 31:0  = arbitrary layer-4 data

The "packet type" field may hold the following values:

RPC_TYPE_CALL(0): A function call. The RPC call number selects one function from a list of up to 256 possible 
operations defined the recipient; the precise meaning of the layer-4 data fields is defined by the recipient but 
they are expected to be used as function arguments. The recipient must respond to this packet, at some arbitrary 
time in the future, with an RPC_RETURN_* packet. The layer-3 protocol does not specify how calls and returns are to 
be matched to one another. Individual modules may choose to allow multiple outstanding requests, in-order or 
out-of-order, as necessary.

RPC_TYPE_RETURN_SUCCESS(1): A successful function return; the function which is returning is identified by the call 
number to aid in disambiguating multiple outstanding requests. The meaning of the layer-4 data fields is defined by 
the sender but they are expected to be used as return values.

RPC_TYPE_RETURN_FAIL(2): An unsuccessful function return; the function which is returning is identified by the call 
number to aid in disambiguating multiple outstanding requests. The meaning of the layer-4 data fields is defined by 
the sender but they are expected to be used as error codes.

RPC_TYPE_RETURN_RETRY(3): An incomplete function return; the particular function is identified by the call number to 
aid in disambiguating multiple outstanding requests. This value is neither successful nor unsuccessful and simply 
indicates that the sending module is too busy to accept this request at the current time; no side effects have 
occurred. The recipient of this message may choose to consider this equivalent to RPC_TYPE_RETURN_FAIL or repeat the 
call at an arbitrary time in the future. The meaning of the layer-4 data fields is defined by the sender but they are 
expected to be used to identify the particular function invocation which needs to be retried.

RPC_TYPE_INTERRUPT(4): A notification that some event has occurred. The RPC call number selects one event from a 
list of up to 256 possible events which may be produced by the sender. The recipient is not expected to respond to 
this message directly, however it may perform any activity (including but not limited to sending other RPC packets) 
as a result of the notification.

Reserved(5): A compliant endpoint node may never produce this value in a packet.

RPC_TYPE_HOST_PROHIBITED(6): Indicates that a previously sent message was dropped by firewalling due to it violating 
some form of security policy. Reserved for future use, a compliant endpoint node may never produce this value in a 
packet.

RPC_TYPE_HOST_UNREACH(7): Indicates that a previously sent message could not be delivered because it was addressed 
to an endpoint node which does not exist on the network. Reserved for future use, a compliant endpoint node may 
never produce this value in a packet.

=================================================

LEMMA 1

CLAIM: RPCv2Transceiver is a "glue" module containing no actual logic - just instances of the modules 
RPCv2Transceiver_transmit and RPCv2Transceiver_receive, each connected to separate ports and sharing no signals 
other than the clock input. Therefore, correctness of RPCv2Transceiver_transmit implies correctness of 
RPCv2Transceiver in the transmit mode.

PROOF: Trivially verifiable by source code inspection.

=================================================

LEMMA 2

CLAIM: When LEAF_PORT is set, the rpc_fab_tx_src_addr input to the RPCv2Transceiver_transmit instance within 
RPCv2Transceiver comes from LEAF_ADDR, a compile-time constant. Otherwise, it is passed through unchanged from the
rpc_fab_tx_src_addr port.

PROOF: Trivially verifiable by source code inspection.

=================================================

LEMMA 3

CLAIM: Correctness of the assertions in /trunk/tests/RPCv2Transceiver_transmit/main.v imply that 
RPCv2Transceiver_transmit produces well-formed packets according to Definition 1.

Furthermore, correctness of the assertions implies that the contents of generated packets (as defined in Definition 2)
are assembled as follows:
* rpc_fab_tx_src_addr = packet source address
* rpc_fab_tx_dst_addr = packet destination address
* rpc_fab_tx_callnum  = RPC call number
* rpc_fab_tx_type     = RPC message type
* rpc_fab_tx_d0       = first layer-4 data word
* rpc_fab_tx_d1       = second layer-4 data word
* rpc_fab_tx_d2       = third layer-4 data word

PROOF: Verifiable by source code inspection.

=================================================

THEOREM 1

CLAIM: RPCv2Transceiver_transmit will always produce well-formed layer-2 RPC packets regardless of input provided 
to the module-side ports.

PROOF:
1) The assertions in /trunk/tests/RPCv2Transceiver_transmit/main.v hold for all possible inputs to the contained 
instance of RPCv2Transceiver_transmit (verifiable by running Yosys's SAT solver on the test script)
2) Therefore, RPCv2Transceiver_transmit always produces correct packets (lemma 3).

=================================================

THEOREM 2

CLAIM: Endpoint nodes containing a RPCv2Transceiver (with no logic between the transceiver's upstream signals and 
the module ports) with LEAF_PORT set to 1, will always produce well-formed layer-2 RPC packets, with a source address 
of LEAF_ADDR, regardless of input provided to the module-side ports.

PROOF:
1) RPCv2Transceiver_transmit will always produce well-formed packets (theorem 1).
2) If RPCv2Transceiver_transmit produces valid packets, then RPCv2Transceiver does (lemma 1)
3) Therefore RPCv2Transceiver produces valid packets.
4) If LEAF_PORT is set to 1, rpc_fab_tx_src_addr on the RPCv2Transceiver_transmit instance equals LEAF_ADDR (lemma 2).
5) If rpc_fab_tx_src_addr equals LEAF_ADDR, then the source address of all sent packets equals LEAF_ADDR (lemma 3)
6) Therefore all transmitted packets are well-formed and have a source address of LEAF_ADDR.
